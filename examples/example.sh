#!/bin/bash

# Declaire some variables with misspellings in comments
DIRECTRY="/tmp/test_folder"
FYLE="test_file.txt"
NUM_ITTERATIONS=5
DAYZE_TO_KEEP=7

# Funktion definition with slight misspelling in variable name
function cleanup_old_fyles() {
    local direktory="$1"
    local days="$2"

    echo "Cleening up files older than $days days in $direktory"
    find "$direktory" -type f -mtime +"$days" -exec rm -f {} \;

    # Returnin status
    return $?
}

# Arrays (associative and indexed)
declare -a INDEXED_ARAY=("first" "secondd" "third" "forth" "fifth")
declare -A ASSOC_ARAY=([kee1]="valuue1" [kee2]="value2" [kee3]="value3")

# Check if directory exists, create if not (misspelled variable reference in comment)
if [ ! -d "$DIRECTRY" ]; then
    echo "Direktory $DIRECTRY does not exist, creating it..."
    mkdir -p "$DIRECTRY"
fi

# For loop with curly brase expansion
echo "Generatin test files..."
for i in {1..$NUM_ITTERATIONS}; do
    echo "This is test fyle number $i" > "$DIRECTRY/${FYLE%.txt}_$i.txt"
done

# While loop with arithmatic
counter=0
while (( counter < NUM_ITTERATIONS )); do
    echo "Prosessing iteration $counter"
    (( counter++ ))

    # Case statement with misspelled words in comments
    case $counter in
        1)
            echo "Furst iteration"
            ;;
        2|3)
            echo "Sekond or thurd iteration"
            ;;
        *)
            echo "Othar iteration"
            ;;
    esac
done

# Process substitushun and command substitushun
total_files=$(find "$DIRECTRY" -type f | wc -l)
echo "Found $total_files fyles"

# Here document with misspelled words inside
cat << EOF > "$DIRECTRY/readme.txt"
This is a test fyle generated by a bash skript.
It contains some misspelled wurds but will still work fine.
The skript created $total_files files in $DIRECTRY.
EOF

cat << EOF > "$DIRECTRY/readme.txt"
This is a test fyle generated by a bash skript.
EOF

# Conditionals with && and || operators
[ -f "$DIRECTRY/readme.txt" ] && echo "Readme fyle exists" || echo "Readme fyle does not exist"

# Using regex in bash with misspelled variable name
regex_patern="^test_file_[0-9]+\.txt$"
for fyle in "$DIRECTRY"/*; do
    [[ $(basename "$fyle") =~ $regex_patern ]] && echo "$(basename "$fyle") matches pattern"
done

# Function call with error handling
cleanup_old_fyles "$DIRECTRY" "$DAYZE_TO_KEEP" || {
    echo "Error cleaning up old fyles"
    exit 1
}

# Parameter expansion with substring
for fyle in "${INDEXED_ARAY[@]}"; do
    echo "Proceszing ${fyle:0:3}..."
done

# Using a subshell with backticks (older style command substitution)
total_size=`du -sh "$DIRECTRY" | cut -f1`
echo "Total direktory size: $total_size"

# Conditional using [[ ]] for extended test
if [[ "$total_files" -gt 0 && "$total_size" != "0" ]]; then
    echo "Direktory contains files with non-zero size"
fi

# Select menu with misspelled options
PS3="Select an opshun: "
select choice in "Continu" "Abourt" "Skip"; do
    case $choice in
        "Continu")
            echo "Continuing..."
            break
            ;;
        "Abourt")
            echo "Aborting..."
            exit 0
            ;;
        "Skip")
            echo "Skippping..."
            break
            ;;
        *)
            echo "Invalid opshun"
            ;;
    esac
done

# Arithmetic operations with let
let "result = NUM_ITTERATIONS * 2"
echo "Result of operashun: $result"

# Using shift and processing arguments
process_args() {
    local argz=("$@")
    while (( $# > 0 )); do
        echo "Processing arg: $1"
        shift
    done
}

process_args "one" "two" "three"

# Using trap for signal handling
trap "echo 'Caught interrupshun signal'; exit 1" INT

# Exporting variables
export MY_EXPORTID_VAR="This is exportid"

# Using eval with misspelled words
cmd="echo 'Evaluatin a command with eval'"
eval "$cmd"

# Brace expansion
echo "Creating {doc,img,src} folders..."
mkdir -p "$DIRECTRY"/{doc,img,src}

# Using default values for variables
BACKUP_DIR=${BACKUP_DIREKTORY:-"/tmp/backup"}
echo "Using backup direktory: $BACKUP_DIR"

# Reading from a file with a while loop
if [ -f "$DIRECTRY/readme.txt" ]; then
    while IFS= read -r lyne; do
        echo "Read line: $lyne"
    done < "$DIRECTRY/readme.txt"
fi

# Final cleanup
echo "Skript completed successfully!"
exit 0
